import { serve } from 'https://deno.land/std@0.168.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
import OpenAI from 'https://esm.sh/openai@4.28.0'

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

interface ChatMessage {
  role: 'user' | 'assistant' | 'system'
  content: string
}

interface ApexRequest {
  message: string
  userId?: string
  conversationHistory?: ChatMessage[]
}

// Fallback response generator when OpenAI is not available
function generateFallbackResponse(message: string, queryResults: any[]): string {
  console.log('üîç Generating response based on database query results for:', message)
  
  // Find relevant results from all three tables
  const faqResults = queryResults.find(r => r.table === 'apex_faqs')?.data || []
  const kbResults = queryResults.find(r => r.table === 'apex_knowledge_base')?.data || []
  const contactResults = queryResults.find(r => r.table === 'apex_contact_info')?.data || []
  
  console.log(`üìä Results found - FAQs: ${faqResults.length}, Knowledge Base: ${kbResults.length}, Contacts: ${contactResults.length}`)
  
  let response = ""
  let hasResults = false
  
  // Include FAQ results if found
  if (faqResults.length > 0) {
    hasResults = true
    response += "**Frequently Asked Questions:**\n\n"
    faqResults.slice(0, 3).forEach((faq) => {
      response += `**Q: ${faq.question}**\n${faq.answer}\n\n`
    })
  }
  
  // Include Knowledge Base results if found
  if (kbResults.length > 0) {
    hasResults = true
    if (response) response += "---\n\n"
    response += "**Knowledge Base Articles:**\n\n"
    kbResults.slice(0, 2).forEach(kb => {
      response += `**${kb.title}**\n${kb.content}\n\n`
    })
  }
  
  // Include Contact results if found
  if (contactResults.length > 0) {
    hasResults = true
    if (response) response += "---\n\n"
    response += "**Contact Information:**\n\n"
    contactResults.forEach(contact => {
      response += `**${contact.department}**\n`
      response += `üìß ${contact.email}\n`
      if (contact.phone) response += `üìû ${contact.phone}\n`
      response += `üïí ${contact.availability}\n`
      response += `${contact.description}\n\n`
    })
  }
  
  // If no results found in any table, return appropriate message
  if (!hasResults) {
    return "I apologize, but I couldn't find specific information about your question in our knowledge base. However, I'm here to help! You can:\n\n‚Ä¢ Contact our support team for personalized assistance\n‚Ä¢ Browse our help documentation\n‚Ä¢ Try rephrasing your question with different keywords\n\nIs there anything else I can help you with?"
  }
  
  return response.trim()
}

// Helper function to execute intelligent queries generated by OpenAI
async function executeIntelligentQuery(query: any, queryResults: any[], supabase: any) {
  const { table, searchFields, searchTerms, purpose } = query
  
  try {
    let supabaseQuery = supabase.from(table).select('*').eq('is_active', true)
    
    if (searchTerms && searchTerms.length > 0 && searchFields && searchFields.length > 0) {
      // Build OR conditions for searching across multiple fields
      const orConditions = []
      
      for (const field of searchFields) {
        for (const term of searchTerms) {
          if (field === 'tags') {
            // Special handling for array fields
            orConditions.push(`tags.cs.{${term}}`)
          } else {
            orConditions.push(`${field}.ilike.%${term}%`)
          }
        }
      }
      
      if (orConditions.length > 0) {
        supabaseQuery = supabaseQuery.or(orConditions.join(','))
      }
    }
    
    // Add ordering and limit
    if (table === 'apex_faqs' || table === 'apex_contact_info') {
      supabaseQuery = supabaseQuery.order('priority', { ascending: false })
    }
    supabaseQuery = supabaseQuery.order('created_at', { ascending: false }).limit(5)
    
    const { data, error } = await supabaseQuery
    
    if (error) {
      console.error(`Query error for ${table}:`, error)
      queryResults.push({
        table,
        data: [],
        purpose,
        error: error.message
      })
    } else {
      console.log(`‚úÖ Intelligent query successful for ${table}, found ${data?.length || 0} results`)
      queryResults.push({
        table,
        data: data || [],
        purpose,
        searchFields,
        searchTerms
      })
    }
  } catch (error) {
    console.error(`Failed to execute intelligent query for ${table}:`, error)
    queryResults.push({
      table,
      data: [],
      purpose,
      error: error.message
    })
  }
}

// Helper function for fallback queries
async function executeFallbackQuery(tableName: string, message: string, queryResults: any[], supabase: any) {
  const searchTerms = message.toLowerCase().split(' ').filter(term => term.length > 2)
  
  try {
    if (tableName === 'apex_faqs') {
      const { data, error } = await supabase
        .from('apex_faqs')
        .select('*')
        .eq('is_active', true)
        .or(searchTerms.map(term => 
          `question.ilike.%${term}%,answer.ilike.%${term}%,category.ilike.%${term}%`
        ).join(','))
        .order('priority', { ascending: false })
        .order('created_at', { ascending: false })
        .limit(3)

      queryResults.push({
        table: 'apex_faqs',
        data: data || [],
        purpose: 'Fallback FAQ search',
        error: error?.message
      })
    } else if (tableName === 'apex_knowledge_base') {
      const { data, error } = await supabase
        .from('apex_knowledge_base')
        .select('*')
        .eq('is_active', true)
        .or(searchTerms.map(term => 
          `title.ilike.%${term}%,content.ilike.%${term}%,category.ilike.%${term}%`
        ).join(','))
        .order('created_at', { ascending: false })
        .limit(3)

      queryResults.push({
        table: 'apex_knowledge_base',
        data: data || [],
        purpose: 'Fallback knowledge base search',
        error: error?.message
      })
    } else if (tableName === 'apex_contact_info') {
      const { data, error } = await supabase
        .from('apex_contact_info')
        .select('*')
        .eq('is_active', true)
        .or(searchTerms.map(term => 
          `department.ilike.%${term}%,description.ilike.%${term}%`
        ).join(','))
        .order('priority', { ascending: false })
        .limit(3)

      queryResults.push({
        table: 'apex_contact_info',
        data: data || [],
        purpose: 'Fallback contact info search',
        error: error?.message
      })
    }
  } catch (error) {
    console.error(`Fallback query failed for ${tableName}:`, error)
  }
}

// Helper function for basic search when OpenAI is not available
async function executeBasicSearch(message: string, queryResults: any[], supabase: any) {
  // Extract meaningful search terms, including important keywords
  const stopWords = ['the', 'and', 'are', 'can', 'how', 'what', 'where', 'when', 'why', 'who', 'is', 'do', 'does', 'will', 'would', 'could', 'should']
  const allWords = message.toLowerCase().split(/\s+/).filter(term => term.length > 1)
  const searchTerms = allWords.filter(term => !stopWords.includes(term))
  
  console.log('üîç Executing comprehensive search across all tables')
  console.log('üìù Original message:', message)
  console.log('üî§ All words:', allWords)
  console.log('üéØ Search terms (after filtering):', searchTerms)
  
  // ALWAYS Query FAQs
  try {
    let faqQuery = supabase
      .from('apex_faqs')
      .select('*')
      .eq('is_active', true)

    // Build OR conditions for each search term
    if (searchTerms.length > 0) {
      const orConditions = searchTerms.flatMap(term => [
        `question.ilike.%${term}%`,
        `answer.ilike.%${term}%`,
        `category.ilike.%${term}%`,
        `tags.cs.{${term}}`
      ]).join(',')
      
      console.log('üìù FAQ OR conditions:', orConditions)
      faqQuery = faqQuery.or(orConditions)
    } else {
      console.log('üìù No search terms found, getting all active FAQs')
    }

    const { data: faqData, error: faqError } = await faqQuery
      .order('priority', { ascending: false })
      .order('created_at', { ascending: false })
      .limit(5)

    if (faqError) {
      console.error('FAQ query error:', faqError)
    }

    console.log(`üìù FAQ search found ${faqData?.length || 0} results`)
    if (faqData && faqData.length > 0) {
      console.log('üìù FAQ results preview:', faqData.map(f => ({ id: f.id, question: f.question?.substring(0, 50) + '...' })))
    }
    queryResults.push({
      table: 'apex_faqs',
      data: faqData || [],
      purpose: 'Search FAQs for relevant Q&A pairs',
      error: faqError?.message
    })
  } catch (error) {
    console.error('FAQ query failed:', error)
    queryResults.push({
      table: 'apex_faqs',
      data: [],
      purpose: 'Search FAQs for relevant Q&A pairs',
      error: error.message
    })
  }

  // ALWAYS Query Knowledge Base
  try {
    let kbQuery = supabase
      .from('apex_knowledge_base')
      .select('*')
      .eq('is_active', true)

    // Build OR conditions for each search term
    if (searchTerms.length > 0) {
      const orConditions = searchTerms.flatMap(term => [
        `title.ilike.%${term}%`,
        `content.ilike.%${term}%`,
        `category.ilike.%${term}%`,
        `tags.cs.{${term}}`
      ]).join(',')
      
      console.log('üìö Knowledge Base OR conditions:', orConditions)
      kbQuery = kbQuery.or(orConditions)
    } else {
      console.log('üìö No search terms found, getting all active Knowledge Base articles')
    }

    const { data: kbData, error: kbError } = await kbQuery
      .order('created_at', { ascending: false })
      .limit(3)

    if (kbError) {
      console.error('Knowledge base query error:', kbError)
    }

    console.log(`üìö Knowledge Base search found ${kbData?.length || 0} results`)
    if (kbData && kbData.length > 0) {
      console.log('üìö Knowledge Base results preview:', kbData.map(k => ({ id: k.id, title: k.title })))
    }
    queryResults.push({
      table: 'apex_knowledge_base',
      data: kbData || [],
      purpose: 'Search knowledge base for detailed articles',
      error: kbError?.message
    })
  } catch (error) {
    console.error('Knowledge base query failed:', error)
    queryResults.push({
      table: 'apex_knowledge_base',
      data: [],
      purpose: 'Search knowledge base for detailed articles',
      error: error.message
    })
  }

  // ALWAYS Query Contact Info
  try {
    let contactQuery = supabase
      .from('apex_contact_info')
      .select('*')
      .eq('is_active', true)

    // Build OR conditions for each search term
    if (searchTerms.length > 0) {
      const orConditions = searchTerms.flatMap(term => [
        `department.ilike.%${term}%`,
        `description.ilike.%${term}%`
      ]).join(',')
      
      contactQuery = contactQuery.or(orConditions)
    }

    const { data: contactData, error: contactError } = await contactQuery
      .order('priority', { ascending: false })
      .limit(3)

    if (contactError) {
      console.error('Contact info query error:', contactError)
    }

    console.log(`üìû Contact Info search found ${contactData?.length || 0} results`)
    queryResults.push({
      table: 'apex_contact_info',
      data: contactData || [],
      purpose: 'Search contact info for relevant departments',
      error: contactError?.message
    })
  } catch (error) {
    console.error('Contact info query failed:', error)
    queryResults.push({
      table: 'apex_contact_info',
      data: [],
      purpose: 'Search contact info for relevant departments',
      error: error.message
    })
  }
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { status: 200, headers: corsHeaders })
  }

  try {
    console.log('ü§ñ APEX AI Assistant request received')
    
    const { message, userId, conversationHistory = [] }: ApexRequest = await req.json()

    if (!message?.trim()) {
      throw new Error('Message is required')
    }

    // Initialize Supabase client
    const supabaseUrl = Deno.env.get('SUPABASE_URL')!
    const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
    const supabase = createClient(supabaseUrl, supabaseServiceKey)

    // Initialize OpenAI client (optional for fallback mode)
    const openaiApiKey = Deno.env.get('OPENAI_API_KEY')
    let openai = null
    if (openaiApiKey) {
      openai = new OpenAI({ apiKey: openaiApiKey })
    } else {
      console.log('‚ö†Ô∏è OpenAI API key not configured, using fallback mode')
    }

    console.log(`üí¨ Processing message: "${message}"`)

    // Execute the queries using Supabase client methods
    const queryResults = []
    
    // If OpenAI is available, use it to generate intelligent queries
    if (openai) {
      console.log('üß† Using OpenAI to generate intelligent database queries...')
      
      try {
        // Get OpenAI to analyze the question and generate appropriate queries
        const queryGenerationPrompt = `You are a database query expert for an LMS platform. Based on the user's question, generate appropriate Supabase client queries to find relevant information.

AVAILABLE TABLES AND SCHEMA:

1. apex_faqs
   - id (uuid)
   - question (text) - The FAQ question
   - answer (text) - The answer to the question
   - category (text) - Category like 'Getting Started', 'Account & Login', 'Courses & Learning', 'AI Features', 'Technical Support'
   - tags (text[]) - Array of searchable tags
   - priority (enum: 'high', 'medium', 'low')
   - is_active (boolean) - Only query active records
   - created_at (timestamptz)

2. apex_knowledge_base
   - id (uuid)
   - title (text) - Article title
   - content (text) - Full article content
   - category (text) - Same categories as FAQs
   - tags (text[]) - Array of searchable tags
   - related_faq_ids (uuid[]) - Related FAQ IDs
   - is_active (boolean) - Only query active records
   - created_at (timestamptz)

3. apex_contact_info
   - id (uuid)
   - department (text) - Department name like 'Technical Support', 'Course Support'
   - email (text) - Contact email
   - phone (text) - Contact phone (optional)
   - availability (text) - Available hours
   - description (text) - What this department handles
   - priority (enum: 'high', 'medium', 'low')
   - is_active (boolean) - Only query active records
   - created_at (timestamptz)

QUERY GUIDELINES:
- Always include .eq('is_active', true)
- Use .ilike() for case-insensitive text searches with % wildcards
- Use .or() for multiple field searches
- Use .order() with priority desc, created_at desc
- Use .limit() to get 3-5 most relevant results
- For array fields like tags, use .contains() or .overlaps()

USER QUESTION: "${message}"

QUERY STRATEGY:
ALWAYS query ALL THREE tables for every user question:
1. apex_faqs - Contains Q&A pairs for quick answers
2. apex_knowledge_base - Contains detailed articles and guides  
3. apex_contact_info - Contains department contact information

IMPORTANT: The apex_knowledge_base table contains detailed articles about:
- "Security and Privacy Features" (tags: security, privacy, data protection)
- "Platform Navigation Guide" (tags: navigation, dashboard, sidebar)
- "AI Learning Stages Overview" (tags: ai, stages, progressive learning)
- "Assignment Submission Best Practices" (tags: assignments, submission, best practices)

Generate a JSON response that ALWAYS includes all three tables:
{
  "queries": [
    {
      "table": "apex_faqs",
      "searchFields": ["question", "answer", "category", "tags"],
      "searchTerms": ["extracted", "terms", "from", "question"],
      "purpose": "Search FAQs for relevant Q&A pairs"
    },
    {
      "table": "apex_knowledge_base",
      "searchFields": ["title", "content", "category", "tags"],
      "searchTerms": ["extracted", "terms", "from", "question"],
      "purpose": "Search knowledge base for detailed articles"
    },
    {
      "table": "apex_contact_info",
      "searchFields": ["department", "description"],
      "searchTerms": ["extracted", "terms", "from", "question"],
      "purpose": "Search contact info for relevant departments"
    }
  ],
  "reasoning": "Brief explanation of your search term extraction approach"
}

CRITICAL: Always include all three tables in your response, even if some seem less relevant.`

        const queryResponse = await openai.chat.completions.create({
          model: 'gpt-4',
          messages: [
            { role: 'system', content: queryGenerationPrompt }
          ],
          temperature: 0.1, // Low temperature for consistent query generation
          max_tokens: 1000
        })

        const queryContent = queryResponse.choices[0]?.message?.content
        if (!queryContent) {
          throw new Error('No query response from OpenAI')
        }

        console.log('üîç OpenAI Query Generation Response:', queryContent)

        let queryPlan
        try {
          queryPlan = JSON.parse(queryContent)
        } catch (parseError) {
          console.error('Failed to parse OpenAI query response:', queryContent)
          throw new Error('Invalid JSON response from OpenAI')
        }

        console.log('üìã Generated Query Plan:', queryPlan)

        // Execute the generated queries
        for (const query of queryPlan.queries) {
          try {
            console.log(`üîé Executing intelligent query on ${query.table}`)
            console.log(`   - Search fields: ${query.searchFields?.join(', ') || 'none'}`)
            console.log(`   - Search terms: ${query.searchTerms?.join(', ') || 'none'}`)
            
            await executeIntelligentQuery(query, queryResults, supabase)

          } catch (queryError) {
            console.error(`Failed to execute query for ${query.table}:`, queryError)
            // Try fallback approach for this table
            await executeFallbackQuery(query.table, message, queryResults, supabase)
          }
        }

      } catch (openaiError) {
        console.error('OpenAI query generation failed, using fallback approach:', openaiError)
        // Fall back to the original search approach
        await executeBasicSearch(message, queryResults, supabase)
      }
    } else {
      console.log('‚ö†Ô∏è OpenAI not available, using basic search approach')
      await executeBasicSearch(message, queryResults, supabase)
    }

    console.log('üìã Query Results:', JSON.stringify(queryResults, null, 2))

    // Generate final response using the query results
    let responseText = ''
    
    if (openai) {
      // Use OpenAI if available for intelligent response generation
      try {
        const responsePrompt = `You are APEX, an AI assistant for an LMS platform. Based on the database query results below, provide a helpful, conversational response to the user's question.

USER QUESTION: "${message}"

DATABASE QUERY RESULTS:
${JSON.stringify(queryResults, null, 2)}

RESPONSE GUIDELINES:
- Be conversational, helpful, and professional
- If you found relevant FAQs, provide direct answers from the FAQ data
- If you found knowledge base articles, summarize the key information
- If you found contact information, provide it when relevant to the question
- If no relevant information was found, acknowledge this and offer general help
- Keep responses concise but complete (aim for 2-3 sentences for simple questions)
- Use a friendly, professional tone
- Don't mention technical details like "database queries" or "query results"
- Focus on being helpful to the user

IMPORTANT: If the query results contain specific FAQ answers that directly address the user's question, use those answers. If multiple relevant results exist, synthesize them into a coherent response.

Provide ONLY the response text, no JSON or additional formatting.`

        const finalResponse = await openai.chat.completions.create({
          model: 'gpt-4',
          messages: [
            { role: 'system', content: responsePrompt },
            ...conversationHistory,
            { role: 'user', content: message }
          ],
          temperature: 0.3, // Lower temperature for more consistent, helpful responses
          max_tokens: 500
        })

        responseText = finalResponse.choices[0]?.message?.content || ''
        console.log('ü§ñ OpenAI generated response:', responseText)
        
      } catch (openaiError) {
        console.error('OpenAI response generation failed, using fallback:', openaiError)
        responseText = generateFallbackResponse(message, queryResults)
      }
    } else {
      // Fallback mode without OpenAI
      console.log('‚ö†Ô∏è Using fallback response generation')
      responseText = generateFallbackResponse(message, queryResults)
    }

    if (!responseText) {
      throw new Error('Failed to generate response')
    }

    console.log('‚úÖ Generated response:', responseText)

    // Log the interaction for analytics
    if (userId) {
      try {
        await supabase
          .from('apex_chat_logs')
          .insert({
            user_id: userId,
            user_message: message,
            ai_response: responseText,
            query_results: queryResults,
            created_at: new Date().toISOString()
          })
      } catch (logError) {
        console.error('Failed to log interaction:', logError)
        // Don't fail the request if logging fails
      }
    }

    return new Response(
      JSON.stringify({
        response: responseText,
        queryResults: queryResults,
        timestamp: new Date().toISOString()
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200
      }
    )

  } catch (error) {
    console.error('‚ùå APEX AI Assistant error:', error)
    
    return new Response(
      JSON.stringify({
        error: 'I apologize, but I\'m experiencing some technical difficulties. Please try again in a moment, or contact our support team for immediate assistance.',
        details: error.message
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500
      }
    )
  }
})
